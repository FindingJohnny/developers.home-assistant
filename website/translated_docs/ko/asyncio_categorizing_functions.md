---
title: "함수의 유형"
---

Home Assistant 내에서 작업은 호출 될 함수로 표현됩니다. 비동기 안전성에 따라 Home Assistant 의 내부에서 이벤트 루프 또는 내부 스레드 풀에서 실행됩니다.

Home Assistant 는 이벤트 루프 내에서 실행해야 할 모든 기능 앞에 `async_` 접두어가 붙는 규칙을 사용합니다.

## 코루틴 함수

코루틴은 결과를 기다리는 동안 실행을 일시 중단 할 수있는 Python 의 생성자 구문을 기반으로하는 특수 함수입니다.

코루틴 함수를 호출하면 생성자 객체가 다시 반환되지만 실제로 실행되지는 않습니다. 이 객체는 작업이 (다른 코루틴 내로 부터) 파생되거나 이벤트 루프에서 예약될 때 작업을 실행합니다.

함수를 코루틴으로 선언하려면 비동기 패키지에서 코루틴 어노테이션을 가져 와서 함수에 어노테이션을 달아주면 됩니다.

```python
async def async_look_my_coroutine(target):
    result = await entity.async_turn_on()
    if result:
        print("hello {}".format(target))

hass.loop.create_task(async_look_my_coroutine("world"))
```

이 예제에서는, `hass.loop.create_task` 를 호출해서 코루틴을 예약했습니다. 이는 실행 될 작업 큐에 코루틴을 추가합니다. 이벤트 루프가 `async_look_my_coroutine` 을 실행중이면 `await entity.async_turn_on()` 이 호출 될 때 작업을 일시 중단합니다. 이 시점에서 `entity.async_turn_on()` 을 실행할 새 작업이 예약됩니다. 해당 작업이 실행되면, `async_look_my_coroutine` 이 다시 재개됩니다.

## 콜백 함수

콜백 함수는 이벤트 루프 내에서 실행되는 것이 안전하다고 간주되는 일반 함수입니다. 콜백은 콜백 자신을 일시 중단 할 수 없으므로 I/O를 수행하거나 코루틴을 호출 할 수 없습니다. 콜백은 새 작업을 예약 할 수는 있지만 결과를 기다릴 수는 없습니다.

함수를 콜백으로 선언하려면 코어 패키지에서 콜백 어노테이션을 가져 와서 함수에 어노테이션을 달아주면 됩니다.

Home Assistant 에서 콜백의 일반적인 사용법은 이벤트 또는 서비스 호출의 수신입니다. 콜백은 들어오는 정보를 처리 한 다음 올바른 호출을 예약 할 수 있습니다. 자동화 컴포넌트의 예제입니다.

```python
from homeassistant.core import callback

@callback
def async_trigger_service_handler(service_call):
    """Handle automation trigger service calls."""
    vars = service_call.data.get(ATTR_VARIABLES)
    for entity in component.async_extract_from_service(service_call):
        hass.loop.create_task(entity.async_trigger(vars, True))
```

이 예제에서 `entity.async_trigger` 는 코루틴 함수 입니다. 코루틴 함수를 호출하면 코루틴 작업이 반환됩니다. 전달 된 매개변수는 작업이 실행될 때 사용됩니다.

작업을 실행하려면 이벤트 루프에서 실행하도록 예약해야 합니다. 이는 `hass.loop.create_task` 를 호출하면 됩니다.

### 왜 콜백이 필요한가요?

코루틴은 콜백이 할 수있는 모든 것을 할 수 있는데 왜 콜백이 필요한지 궁금 할 겁니다. 그 이유는 성능과 코어 API 객체의 상태 일관성이 더 좋기 때문입니다.

코루틴 A 가 코루틴 B 를 기다리면, 코루틴 자체를 일시 중단하고 코루틴 B 를 실행하는 새 작업을 예약합니다. 이는 이벤트 루프가 A, B 를 실행하고나서 A를 다시 실행함을 의미합니다. 만약 B 가 콜백이면, A 는 절대로 자신을 일시 중지 할 필요가 없으므로 이벤트 루프는 A를 실행 중일뿐입니다. 여기서 일관성의 의미는 이벤트 루프에서 실행되도록 대기중인 다른 이벤트는 콜백이 완료 될 때까지 계속 대기하지만, 콜백은 다른 코루틴으로 파생될 때 인터리빙(끼워넣기) 되게 됩니다.

## 이벤트 루프와 스레드 안전

이 함수들은 스레드 와 이벤트 루프 내에서 실행하기에 안전한 함수들입니다. 이러한 함수는 대개 메모리에서 계산 또는 데이터 변조를 수행합니다. I/O 를 수행하는 것은 이 범주에 속하지 않습니다. 많은 표준 라이브러리 함수가 이 범주에 속합니다. 예를 들면, 합계 혹은 두 딕셔너리 자료의 병합을 사용해서 숫자 셋트의 합계를 생성하는 함수들입니다.

이 부류의 일부로 함수를 마크하는 특별한 어노테이션은 없으며 이벤트 루프 내에서 이러한 함수를 사용할 때는 주의를 기울여야 합니다. 의심스럽다면 구현된 내용을 살펴봐주세요.

## 기타 함수

이 함수들은 이전 부류에 맞지 않는 모든 함수들을 말합니다. 이러한 함수는 스레드 혹은 이벤트 루프 내에서 실행하기에 안전하지 않은 것으로 간주합니다. 이들은 슬립을 사용하거나 I/O 를 수행하는 함수입니다.

이 부류의 일부로 간주되기위해 필요한 특별한 어노테이션은 없습니다.